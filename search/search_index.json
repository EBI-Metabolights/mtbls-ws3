{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#metabolights-ws3","title":"MetaboLights WS3","text":"<p>The <code>mtbls-ws3</code> is Python application stack to manage MetaboLights open repository. It provides REST API endpoints for the metabolomics community and other MetaboLights applications.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>REST API endpoints with FastAPI and API documentation (Redoc).</li> <li>Json serializable models with pydantic library.</li> <li>Serve the selected REST API endpoints (e.g., submission, curation, public, etc.).</li> <li>A new design with best practices, including dependency inversion, testability, modularity, maintainability, and extensibility.</li> <li>Jwt based extensible authentication, authorization, identity management</li> <li>Improved logging mechanism</li> </ul>"},{"location":"#development-environment","title":"Development Environment","text":"<p>Development environment for linux or mac</p> <pre><code># install python package manager uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# add $HOME/.local/bin to your PATH, either restart your shell or run\nexport PATH=$HOME/.local/bin:$PATH\n\n# If there is no git, install it from https://git-scm.com/downloads\n# Linux command to install git\n# apt update; apt install git -y\n\n# Mac command to install git\n# brew install git\n\n# clone project from github\ngit clone https://github.com/EBI-Metabolights/mtbls-ws3.git\n\ncd mtbls-ws3\n\n# install python with uv\nuv python install 3.13\n\n# install python dependencies\nuv sync --extra ws3\n\n# install pre-commit to check repository integrity and format checking\nuv run pre-commit\n#########################################################################################\n# \ud83d\udd0d Validate pyproject.toml...................................(no files to check)Skipped\n# \ud83d\udd12 Security \u00b7 Detect hardcoded secrets...........................................Passed\n# \ud83d\udfe2  Markdown \u00b7 Format markdown...................................................Passed\n# \ud83d\udfe2  Check large files............................................................Passed\n# \ud83d\udfe2  Check toml files.........................................(no files to check)Skipped\n# \ud83d\udfe2  Check json files.........................................(no files to check)Skipped\n# \ud83d\udfe2  Format json files........................................(no files to check)Skipped\n# \ud83d\udfe2  Check yaml files.............................................................Passed\n# \ud83d\udfe2 Check end of file character...................................................Passed\n# \ud83d\udfe2  Check training whitespaces...................................................Passed\n# \u2705 Check training whitespaces................................(no files to check)Skipped\n# \ud83d\udd0d Detect missing __init__.py files..............................................Passed\n# \ud83d\udd0d Check Format with Ruff....................................(no files to check)Skipped\n# \ud83d\udc0d python \u00b7 Format with Ruff.................................(no files to check)Skipped\n# \ud83e\udeb5 architecture and package structure check (lint-imports).......................Passed\n#########################################################################################\n\nuv run pytest\n\n# Run and test webservice server on local\n# test curator metabolights-help@ebi.ac.uk with password test.123\n# test user metabolights-dev@ebi.ac.uk with password test.123\n# test studies MTBLS800001 MTBLS800002 MTBLS800003\nuv run python tests/run/main_local.py\n\n# open your IDE (vscode, pycharm, etc.) and set python interpreter as .venv/bin/python\n</code></pre>"},{"location":"#design-development","title":"Design &amp; Development","text":"<p>You can find design details Design Section</p> <p>Before committing and pushing your updates:</p> <ul> <li>Add/update unit tests.</li> <li>Run following commands and fix all issues and</li> </ul> <pre><code>uv run lint-imports\n\nuv run pre-commit\n\nuv run pytest\n</code></pre>"},{"location":"design/architecture/","title":"Overview","text":"<p>MetaboLights WS3 is designed to address the latest goals and requirements of MetaboLights.</p> <ul> <li><code>Separation of Concerns</code>: Each concern (presentation, business logic, and data access) should be clearly separated. Specifically, the business logic should remain independent of the details of data storage and management.</li> <li><code>Maintainability</code>: The architecture must support long-term maintainability. This requires clearly defined layers that adhere to the principle of separation of concerns, avoiding framework-dependent or tightly coupled (\u201cspaghetti\u201d) code. Layer structures and their dependencies should be automatically validated to ensure architectural integrity.</li> <li><code>Framework Independence</code>: The business logic layer must remain independent of external frameworks. This promotes flexibility, allowing frameworks to be upgraded or substituted with minimal impact on the rest of the system. In MetaboLights, reliance on specific frameworks and external services has historically led to major issues during application and infrastructure upgrades.</li> <li><code>Testability</code>: The architecture should allow application configurations to be easily modified and support the execution of unit, integration, functional, and non-functional tests.</li> <li><code>Extensible</code>: The architecture should be extensible, allowing new components or frameworks to be added with minimal effort.</li> <li><code>Flexible</code>: The architecture should support the definition and execution of multiple application types\u2014such as REST API servers and command-line interfaces\u2014within a single codebase or repository.</li> <li><code>Scalable</code>: Each application should operate as a stateless service that can be easily deployed within a containerized infrastructure.</li> </ul> <p>Inspiration</p> <p>MetaboLights WS3 is inspired from the following software principals, architectures and approaches:</p> <ul> <li>SOLID (Single-responsibility, Open-closed Principle, Liskov substitution, Interface segregation, Dependency inversion) Object Oriented Design Principles.</li> <li>Domain Driven Design (DDD)</li> <li>Command Query Responsibility Segregation (CQRS)</li> <li>Clean Architecture</li> <li>Onion Architecture</li> <li>Hexagonal / Port &amp; Adaptor Architecture</li> </ul>"},{"location":"design/architecture/#metabolights-ws3-architecture","title":"MetaboLights WS3 Architecture","text":"<p>The MetaboLights WS3 architecture consists of four core layers \u2014 <code>domain</code>, <code>application</code>, <code>presentation</code>, and <code>infrastructure</code> \u2014 along with an additional <code>run</code> layer used to customize endpoints and executables. The layers and their dependency hierarchy are illustrated below.</p> <p></p>"},{"location":"design/architecture/#general-design-principles","title":"General design principles","text":"<ul> <li>Each layer can use the lower layer(s) but not higher layers. For example, <code>infrastructure</code> layer can import both <code>application</code> and <code>domain</code> layer modules, however <code>application</code> layer can only import modules from <code>domain</code> layer.</li> <li><code>infrastructure</code> and <code>presentation</code> layers are on the same level and they are isolated. They do not import any modules from each other.</li> <li>All external services (e.g., external web services) and python package dependencies (postgresql, redis, elasticsearch, etc.) are isolated from <code>application</code> layer modules. Application modules only use interfaces. Interfaces are implemented in <code>infrastructure</code> layer. For example, CacheService interface in <code>application</code> layer can be implemented with different frameworks (RedisCache, InMemoryCache, RedisSentinelCache, etc.) in <code>infrastructure</code>.</li> <li><code>application</code> layer modules do not know how domain entities are stored and managed (on NFS, SQL or NoSQL DB, Object Storage, etc.). They use only repository interfaces to process them.</li> <li>Only <code>presentation</code> layer modules will check authentication or authorization (Role based authentication and authorization). There will be no logic to check authentication or authorization in <code>application</code> or <code>infrastructure</code> layer modules (They may access authentication and authorization information in read-only mode).</li> <li>All application logic should be implemented in <code>application</code> layer (not in <code>presentation</code> or <code>infrastructure</code> layer).</li> <li><code>presentation</code> layer modules should implement only RestAPI or CLI inputs and outputs (authentication and authorization). Any business logic should be moved to application and domain layer.</li> <li><code>Infrastructure</code> layer modules should implement only application interfaces. For example, HttpClient interface has <code>send_request</code> method and HttpxClient in <code>Infrastructure</code> layer implements send_request method using httpx module.</li> <li>Do not use any external python package dependencies in <code>domain</code> or <code>application</code> layer (Exceptions: pydantic).</li> <li><code>dependency_injector</code> containers will be defined for each executable (ws, ws_worker, cli, etc) in <code>run</code> layer.</li> <li>Prefer async coroutines for time consuming operations (external service calls, time consuming tasks etc.)</li> </ul>"},{"location":"design/architecture/#layers-and-design-principles","title":"Layers and design principles","text":""},{"location":"design/architecture/#domain-layer","title":"Domain layer","text":"<p>Domain layer contains only MetaboLights specific domain classes, enumerations, decorators, exceptions and basic utility methods.</p> <ul> <li><code>Domain</code> layer imports only <code>core Python packages</code> and the following libraries:</li> <li><code>pydantic</code></li> <li><code>metabolights-utils</code></li> <li>Basic utility libraries: <code>pyyaml</code>, <code>python-dateutil</code>, <code>pytz</code></li> </ul>"},{"location":"design/architecture/#application-layer","title":"Application layer","text":"<ul> <li> <p><code>Application</code> layer imports only <code>domain</code> layer packages. The only exception is <code>dependency_injector</code> to define async tasks.</p> </li> <li> <p>All methods and classes in <code>application</code> layer use interfaces to access infrastructure components and services.</p> </li> <li> <p><code>Application</code> layer modules do not import any external python libraries (e.g., celery, redis, sqlachemy, etc.). Instead of importing any external library, a new service or component can be implemented in <code>infrastructure</code> layer. To implement a new service or component:</p> </li> <li> <p>Define interfaces in <code>application</code> layer.</p> </li> <li>Create any required domain objects in <code>domain</code> layer.</li> <li>Implement interfaces in <code>infrastructure</code> layer.</li> <li> <p>Update <code>dependency_injector</code> container in <code>run</code> layer to use it.</p> </li> <li> <p>Initial interfaces in <code>application</code> layers are listed below:</p> </li> <li> <p><code>HttpClient</code></p> </li> <li><code>AsyncTaskService</code></li> <li><code>AuthenticationService</code>, <code>AuthorizationService</code> and <code>IdentityService</code></li> <li><code>CacheService</code></li> <li><code>PolicyService</code></li> <li> <p><code>StudyMetadataService</code></p> </li> <li> <p>Repositories are also defined as interfaces. e.g. <code>Study</code>, <code>User</code>, <code>ValidationReport</code>, <code>ValidationOverride</code>, <code>StudyFile</code>, etc. entity repositories.</p> </li> <li> <p>Application related logic is implemented in <code>use_cases</code> package. any module in <code>use_cases</code> package can import any other packages in <code>application</code> layer.</p> </li> <li> <p>All async tasks are implemented in <code>remote_tasks</code> package and they do not import <code>use_cases</code> modules.</p> </li> </ul> <p>You can find <code>application</code> layer packages and their dependency hierarchy below:</p> <p></p>"},{"location":"design/architecture/#presentation-layer","title":"Presentation layer","text":"<ul> <li><code>Presentation</code> layer can imports <code>application</code> and <code>domain</code> layer packages. It may also import <code>dependency_injector</code> and presentation related libraries (e.g., FastAPI, click).</li> <li><code>Presentation</code> layer do not import any <code>infrastructure</code> layer packages packages and modules.</li> <li>Rest API, CLI or other executable can be defined as a presentation.</li> <li>Rest API endpoints are defined within API groups and each API group will be managed with versions. Initial Rest API groups are <code>submission</code>,<code>auth</code>, <code>curation</code>, <code>system</code>, and <code>public</code> .</li> <li><code>Submission Rest API group</code>: It provides endpoints to create and update MetaboLights submissions. Authentication is required to use endpoints.</li> <li><code>Curation Rest API group</code>: It provides endpoints to run curation tasks on submitted studies and make them public. Authentication is required to use endpoints.</li> <li><code>Public Rest API group</code>: It provides endpoints to access MetaboLights public studies and statistics.</li> <li><code>Auth Rest API group</code>: It provides to endpoints to create and revoke API tokens (JWT tokens).</li> <li><code>System Rest API group</code>: It provides to endpoints to MetaboLights sytem related endpoints (Private FTP accessibility, etc.).</li> <li>Only JWT token is used to authorize requests. Each user or service that wants to access any authorized endpoints should have a valid JWT token.</li> <li>Rest API authentication will be managed within authorization middleware.</li> </ul>"},{"location":"design/architecture/#infrastructure-layer","title":"Infrastructure layer","text":"<ul> <li><code>Infrastructure</code> layer modules can import <code>application</code> and <code>domain</code> layer modules, <code>dependency_injector</code> module and any external library (e.g., redis, slqalchemy, elasticsearch, celery, etc.).</li> <li><code>Infrastructure</code> layer modules do not import any <code>presentation</code> layer modules.</li> <li>Multiple implementations can be defined for an interface defined in <code>application</code> layer. Each implementation is isolated from each others.</li> <li>Initial Service and repository implementations:</li> <li>AsyncTaskService: <code>Celery</code> and <code>thread</code> (for development) implementations</li> <li>AuthenticationService, AuthorizationService and IdentityService: <code>mtbls_ws2 proxy</code> and <code>standalone</code> implementations.</li> <li>CacheService: <code>Redis</code>, <code>Redis sentinel</code> and <code>in-memory</code> (for development) implementations</li> <li>PolicyService: Open policy agency (<code>OPA</code>) implementation</li> <li>StudyMetadataService: <code>NFS</code> and <code>mongodb</code> (in progress) implementations</li> <li>ValidationOverrideService, ValidationReportService: <code>NFS</code> and <code>mongodb</code> (in progress) implementations</li> <li>Repositories:<ul> <li><code>Study</code> &amp; <code>User</code>: <code>postgresql</code> and <code>sqlite</code> (for development) implementations</li> <li><code>ValidationReport</code> &amp; <code>ValidationOverride</code>: <code>NFS</code> and <code>mongodb</code> (in progress)</li> <li><code>InvestigationFileObject</code>, <code>IsaTableObject</code> (<code>SampleFile</code>, <code>AssayFile</code> <code>AssignmentFile</code>): <code>NFS</code> and <code>mongodb</code> (in progress)</li> <li><code>FileObject</code>: to store data folder content. <code>NFS</code> (in progress) and <code>mongodb</code> (in progress)</li> </ul> </li> </ul>"},{"location":"design/architecture/#run-layer","title":"Run layer","text":"<ul> <li><code>Run</code> layer defines <code>dependency_injector</code> container and runs an executable in <code>presentation</code> layer (submission API, submission API worker, CLI, etc.).</li> <li>Initial executables are:</li> <li><code>Submission Rest API</code>: It uses celery async application, NFS and PostgreSQL based repositories, redis cache service and proxy authentication service.</li> <li><code>Submission Rest API Worker</code>: Celery worker to run submission remote tasks</li> <li><code>Submission Rest API Worker Monitor</code>: Flower executable to monitor celery tasks</li> <li><code>CLI</code>: Initial commandline tool named <code>mtbls-tools</code></li> <li>Log filters and application configuration files are customized depends on selected presentation layer application and service implementations.</li> <li>Unit tests overrides async task, auth, and cache services. Postgresql database is also overriden by Sqlite database to run unit tests.</li> </ul>"},{"location":"design/aspects/async_tasks/","title":"Async and Remote Tasks","text":"<p>Async task is an entry point method to run on another server or process. There are two implementations:</p> <ul> <li><code>Celery</code>: Celery workers process the tasks</li> <li><code>Threading</code>: Tasks run in a thread (local development only)</li> </ul> <p>Async tasks should be decorated with <code>@async_task</code> and registered before starting application.</p> <pre><code>modules = find_async_task_modules(app_name=app_name, queue_names=queue_names)\nasync_task_modules = load_modules(modules, module_config)\n</code></pre> <pre><code>async_task_service: AsyncTaskService = providers.Singleton(\n    CeleryAsyncTaskService,\n    broker=gateways.pub_sub_broker,\n    backend=gateways.pub_sub_backend,\n    app_name=\"default\",\n    queue_names=[\"common\", \"validation\", \"datamover\", \"compute\", \"\"],\n    async_task_registry=core.async_task_registry,\n)\n</code></pre>"},{"location":"design/aspects/auth/","title":"Authentication, Authorization and Identity Management","text":"<p>User authentication will be managed centrally for Rest API endpoints. Endpoints can check authentication information (authenticated or unauthenticated) to apply business rules (e.g. submitters can update study status if study is validated.)</p>"},{"location":"design/aspects/auth/#general-design-and-coding-principles","title":"General design and coding principles","text":"<ul> <li>Authentication can be completed with username/password or user API token. After authentication, a new JWT token will be created and shared with user.</li> <li>Users use the generated JWT tokens to access restricted endpoints.</li> <li>JWT tokens will be validated by authentication service. Neither other services nor endpoints will check JWT token.</li> <li>Authenticated or unauthenticated user information will be stored in request context. Other services or endpoints can access it.</li> <li>If a request has a JWT token and it is not valid (e.g. invalid format, expired, etc.), authentication service will return error message .</li> <li>If the requested path contains resource id (MTBLS, REQ), authorization service checks permissions for the user. Other services or endpoints can access permission.</li> </ul>"},{"location":"design/aspects/auth/#authentication","title":"Authentication","text":"<p>Authentication service methods are shown below. Implementations should support at least JWT_TOKEN token and username/password authentications. Default implementatations are listed below:</p> <ul> <li><code>standalone</code>: Create and check JWT tokens. User information is fetched from database.</li> <li><code>mtbls_ws2</code>: It is a proxy service and use mtbls_ws2 endpoints for authentications.</li> </ul> <pre><code>class AuthenticationService(abc.ABC):\n    @abc.abstractmethod\n    async def authenticate_with_token(self, token_type: TokenType, token: str) -&gt; str:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    async def authenticate_with_password(self, username: str, password: str) -&gt; str:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    async def revoke_jwt_token(self, jwt: str) -&gt; str:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    async def validate_token(self, token_type: TokenType, token: str) -&gt; str:\n        raise NotImplementedError()\n</code></pre> <p>Authentication service is used by a middleware service, and UnauthenticatedUser / AuthenticatedUser object is injected to request.</p> <pre><code>class AuthBackend(AuthenticationBackend):\n    def __init__(\n        self,\n        authentication_service: AuthenticationService,\n        user_read_repository: UserReadRepository,\n    ):\n        self.authentication_service = authentication_service\n        self.user_read_repository = user_read_repository\n\n    async def authenticate(self, conn):\n        if \"Authorization\" not in conn.headers:\n            return AuthCredentials({\"unauthenticated\"}), UnauthenticatedUser()\n\n        auth = conn.headers[\"Authorization\"]\n\n        username = await self.validate_credential(auth)\n\n        if not username:\n            return AuthCredentials({\"unauthenticated\"}), UnauthenticatedUser()\n        user: UserOutput = await self.user_read_repository.get_user_by_username(\n            username\n        )\n        if not user:\n            logger.error(\n                \"User role check failure. \"\n                \"User %s details are not fetched by from database.\",\n                username,\n            )\n            raise AuthenticationError(\"User details are not fetched from database\")\n        scopes = {\"authenticated\"}\n        if user.role == UserRole.SUBMITTER:\n            scopes.add(\"submitter\")\n        elif user.role == UserRole.CURATOR:\n            scopes.add(\"curator\")\n            scopes.add(\"submitter\")\n        elif user.role == UserRole.SYSTEM_ADMIN:\n            scopes.add(\"admin\")\n\n        return AuthCredentials(scopes), AuthenticatedUser(user)\n</code></pre> <p>Each endpoint can check UnauthenticatedUser / AuthenticatedUser object. if only authorized users can access, endpoint should raise <code>AuthenticationError</code> exception.</p> <pre><code>logger = logging.getLogger(__name__)\n\n\nasync def check_read_permission(\n    resource_id: Annotated[str, RESOURCE_ID_IN_PATH],\n    jwt_token: Union[None, str] = Security(oauth2_scheme.oauth2_scheme),\n    request: Request = None,\n) -&gt; StudyPermissionContext:\n    get_request_tracker().resource_id_var.set(resource_id if resource_id else \"-\")\n\n    if isinstance(request.user, AuthenticatedUser):\n        if not jwt_token:\n            raise AuthenticationError(\"Invalid jwt token.\")\n        context = request.user.permission_context\n        if not context or not context.study or not context.permissions.read:\n            logger.warning(\n                \"User %s is not granted to view resource %s\",\n                context.user.id_,\n                resource_id,\n            )\n            raise AuthorizationError(\n                f\"User {context.user.id_} is not granted to view resource {resource_id}\"\n            )\n        logger.debug(\n            \"User %s is granted to view resource %s\",\n            context.user.id_,\n            resource_id,\n        )\n        return context\n    elif isinstance(request.user, UnauthenticatedUser):\n        context = request.user.permission_context\n        if context and context.study and context.study.status == StudyStatus.PUBLIC:\n            logger.debug(\n                \"Unauthenticated user is granted to view PUBLIC resource %s\",\n                resource_id,\n            )\n            return context\n\n    logger.warning(\n        \"Unauthenticated user %s is not granted to view resource  %s\",\n        resource_id,\n    )\n    raise AuthorizationError(f\"User has no authorization to read {resource_id}.\")\n</code></pre>"},{"location":"design/aspects/auth/#authorization","title":"Authorization","text":"<p>The authorization service determines the user's permissions for the requested resource (MTBLSxxx or REQxxx) and can be used by any endpoint.</p> <pre><code>class AuthorizationService(abc.ABC):\n    @abc.abstractmethod\n    async def get_permissions(\n        self,\n        username: Union[None, str],\n        resource_id: str,\n        sub_resource: Union[None, str] = None,\n    ) -&gt; StudyPermissionContext: ...\n\n    @abc.abstractmethod\n    async def get_user_resource_permission(\n        self,\n        user: Union[None, UserOutput],\n        resource_id: str,\n        sub_resource: Union[None, str] = None,\n    ) -&gt; StudyPermissionContext: ...\n</code></pre> <p>It returns <code>StudyPermissionContext</code> object that defines all possible user's permissions (read, write, delete, create).</p> <pre><code>class ResourcePermission(BaseModel):\n    create: bool = False\n    read: bool = False\n    update: bool = False\n    delete: bool = False\n\n\nclass PermissionContext(abc.ABC, BaseModel, Generic[T, R]):\n    user: Union[None, T] = None\n    is_owner: bool = False\n    study: Union[None, R] = None\n    permissions: ResourcePermission = ResourcePermission()\n    parameters: dict[str, Any] = {}\n\n\nclass StudyPermissionContext(PermissionContext[UserOutput, StudyOutput]): ...\n</code></pre> <p>If there is a resource_id (or study_id) in the requested path (/../MTBLS1/..), <code>AuthorizationMiddleware</code> updates permission_context field of UnauthenticatedUser / AuthenticatedUser in request. Endpoints that include a resource_id in the request path can use it directly without requiring the authorization service. <code>AuthorizationMiddleware</code> also can check request paths and authorize request. If user has no permission to access the requested resource, <code>AuthorizationMiddleware</code> raises <code>AuthorizationError</code>. Path prefixes and allowed roles can be defined in configuration file.</p> <p>Path Authorization Example</p> <p>All endpoints starting with /submissions/ are restricted to users with the 'curator' or 'submitter' roles (some 'READ' exceptions if resource is public). Endpoints starting with /curation/ are accessible only to curators.</p> <pre><code>    authorized_endpoints:\n    - prefix: \"/submissions/\"\n      scopes:\n      - curator\n      - submitter\n    - prefix: \"/curation/\"\n      scopes:\n      - curator\n</code></pre>"},{"location":"design/aspects/auth/#identity-management","title":"Identity Management","text":"<p>User identities (username, password hash, role etc.) are stored on database.</p>"},{"location":"design/aspects/configuration/","title":"Configuration","text":"<p>Application configurations will be defined in yaml file(s) and managed by dependency injection mechanism.</p>"},{"location":"design/aspects/configuration/#general-design-and-coding-principles","title":"General design and coding principles","text":"<ul> <li>The content and structure of a configuration file is dynamic and depends on the application's dependency container and selected service/repository implementations.</li> <li>Application dependency container loads configuration file and uses its content to initiate container elements (resource, service, repository, etc.).</li> <li>Any configuration related to business logic can be defined in config file. They can be injected by dependency injection mechanism.</li> </ul> <p>Example</p> <p>The following example loads <code>config.yaml</code> file and sets it to core container. Core container uses <code>run.submission.logging</code> sub element.</p> <p>On the other hand, Only <code>gateways</code> sub element of config file is set to gateways container and gateway container uses <code>gateways.database.postgresql.connection</code> sub element of config file.</p> <p>Example Configuration File</p> <pre><code>gateways:\n  ...\n  database:\n    postgresql:\n      connection:\n        host: remote-host\n        port: 32069\n        user: test\n        password: {{ postgresql.database }}\n        database: sample\n        url_scheme: postgresql+asyncpg\nrun:\n  ...\n  submission:\n    logging:\n      version: 1\n      disable_existing_loggers: true\n      formatters:\n        json_formatter:\n          format: '{ \"level_name\": \"%(levelname)s\", \"time\": \"%(asctime)s\",  \"client\": \"%(client)s\",  \"path\": \"%(route_path)s\", \"resource_id\": \"%(resource_id)s\", \"user\": %(user_id)d, \"request_id\": \"%(request_id)s\", \"name\": \"%(name)s\", \"message\": \"%(message)s\" }'\n        text_formatter:\n          format: '%(levelname)-8s %(asctime)s %(user_id)d %(client)s %(route_path)s %(resource_id)s %(request_id)s %(name)s \"%(message)s\"'\n      handlers:\n        console:\n          class: \"logging.StreamHandler\"\n          level: DEBUG\n          formatter: \"json_formatter\"\n          stream: \"ext://sys.stdout\"\n          filters: [ default_filter, correlation_id ]\n      root:\n        level: DEBUG\n        handlers: [ \"console\" ]\n        propogate: true\n      loggers:\n        mtbls:\n          level: DEBUG\n          propogate: yes\n      ...\n</code></pre> <p>Example Container Definition</p> <pre><code>class Ws3CoreContainer(containers.DeclarativeContainer):\n    config = providers.Configuration()\n\n    logging_config = providers.Resource(\n        logging_config.dictConfig,\n        config=config.run.submission.logging,\n    )\n    async_task_registry = providers.Resource(get_async_task_registry)\n\nclass GatewaysContainer(containers.DeclarativeContainer):\n    config = providers.Configuration()\n    runtime_config = providers.Configuration()\n    database_client: DatabaseClient = providers.Singleton(\n        DatabaseClientImpl,\n        db_connection=config.database.postgresql.connection,\n        db_pool_size=runtime_config.db_pool_size,\n    )\n\nclass Ws3ApplicationContainer(containers.DeclarativeContainer):\n    config = providers.Configuration()\n\n    core = providers.Container(\n        Ws3CoreContainer,\n        config=config,\n    )\n\n    gateways = providers.Container(\n        GatewaysContainer,\n        config=config.gateways,\n    )\n</code></pre>"},{"location":"design/aspects/configuration/#secrets","title":"Secrets","text":"<p>Secrets are stored in a different yaml file. They are referenced in config file as a template (e.g.<code>{{ postgresql.password }}</code> ) and rendered with <code>Jinja2</code> template framework.</p> <p>Each application should render config file after creating dependency container.</p> <pre><code>class Ws3ApplicationContainer(containers.DeclarativeContainer):\n    config = providers.Configuration()\n    secrets = providers.Configuration()\n    core = providers.Container(\n        Ws3CoreContainer,\n        config=config,\n    )\n\n...\n# initiate container and render secrets\ncontainer = Ws3ApplicationContainer()\nset_application_configuration(\n        container,\n        config_file_path=\"tests/data/config/mtbls-base-config.yaml\",\n        secrets_file_path=\"tests/data/config/mtbls-base-config-secrets.yaml\",\n    )\ncontainer.init_resources()\n...\n</code></pre> <p>Example config.yaml</p> <pre><code>gateways:\n  ...\n  database:\n    postgresql:\n      connection:\n        host: remote-host\n        port: 32069\n        user: xyz\n        password: {{ postgresql.database }}\n        database: testdb\n        url_scheme: postgresql+asyncpg\n</code></pre> <p>Example config-secrets.yaml</p> <pre><code>redis:\n  password: redis_ws1\npostgresql:\n  password: test.123\nstandalone_authentication:\n  application_secret_key: application-test.123\n</code></pre>"},{"location":"design/aspects/dependency_inversion/","title":"Dependency Inversion","text":"<p>Dependency injection is a common practice to decrease coupling and increase cohesion. It has three main advantages:</p> <ul> <li><code>Flexibility</code>: It enables to develop loosely coupled components. An application can be extended or changed easily by using the components in a different way.</li> <li><code>Testability</code>: Services or resources can be overriden and mock objects can be injected easily.</li> <li><code>Maintainability</code>: Dependency injection helps to manage all dependencies. All components and dependencies defined explicitly in a container.</li> </ul>"},{"location":"design/aspects/dependency_inversion/#general-design-and-coding-principles","title":"General design and coding principles","text":"<ul> <li><code>dependency_injector</code> framework will be used for singleton, factory, configuration and resource dependency injection capabilities.</li> <li>Dependency containers will be defined for each executable in <code>run</code> layer.</li> <li>Dependencies will be wired to only Rest API endpoints, async tasks and <code>run</code> layer modules. All others will not import dependency injection library and need to define inputs to use interfaces.</li> </ul>"},{"location":"design/aspects/dependency_inversion/#dependency-containers","title":"Dependency containers","text":"<p>Any dependency container will be created for</p> <ol> <li>Selecting and defining service implementations and their dependencies (e.g. CacheService with RedisCacheService)</li> <li>Selecting and defining repository implementations and their dependencies for domain entities (postgreSQL, NFS, Mongo)</li> <li>Selecting and initiating application configuration (e.g. different config.yaml files for prod or development)</li> <li>Initiating application level variables and triggering global functions (logging configuration, async task registry, request tracker, etc.)</li> </ol> <p>Dependency container</p> <p>You can find an example container definition below. It defines repositories and their implementations, and assigns the initiation parameters as well.</p> <pre><code>class RepositoriesContainer(containers.DeclarativeContainer):\n    config = providers.Configuration()\n    entity_mapper: EntityMapper = providers.Singleton(EntityMapper)\n\n    alias_generator: AliasGenerator = providers.Singleton(\n        DbTableAliasGeneratorImpl, entity_mapper\n    )\n\n    gateways = providers.DependenciesContainer()\n    services = providers.DependenciesContainer()\n    study_read_repository: StudyReadRepository = providers.Singleton(\n        SqlDbStudyReadRepository,\n        entity_mapper=entity_mapper,\n        alias_generator=alias_generator,\n        database_client=gateways.database_client,\n    )\n    study_write_repository: StudyWriteRepository = providers.Singleton(\n        SqlDbStudyWriteRepository,\n        entity_mapper=entity_mapper,\n        alias_generator=alias_generator,\n        database_client=gateways.database_client,\n    )\n    user_write_repository: UserWriteRepository = providers.Singleton(\n        SqlDbUserWriteRepository,\n        entity_mapper=entity_mapper,\n        alias_generator=alias_generator,\n        database_client=gateways.database_client,\n    )\n\n    user_read_repository: UserReadRepository = providers.Singleton(\n        SqlDbUserReadRepository,\n        entity_mapper=entity_mapper,\n        alias_generator=alias_generator,\n        database_client=gateways.database_client,\n    )\n\n    statistic_read_repository: StatisticReadRepository = providers.Singleton(\n        SqlDbStatisticReadRepository,\n        entity_mapper=entity_mapper,\n        alias_generator=alias_generator,\n        database_client=gateways.database_client,\n    )\n\n    folder_manager = providers.Singleton(\n        StudyFolderManager, config=config.repositories.study_folders\n    )\n</code></pre>"},{"location":"design/aspects/dependency_inversion/#dependency-injection-to-call-rest-api-endpoints","title":"Dependency injection to call Rest API endpoints","text":"<p>Example</p> <p>The following example shows how a dependency is injected into a Rest API endpoint. Endpoint uses the injected service to call a business logic method in application layer</p> <pre><code>logger = getLogger(__name__)\n\nrouter = APIRouter(tags=[\"Study Validation Overrides\"], prefix=\"/curation/v1\")\n\n\n@router.patch(\n    \"/{resource_id}/validation-overrides\",\n    summary=\"Patch validation overrides for the study\",\n    description=\"Adds new override if it is not overrides list \",\n    response_model=APIResponse[ValidationOverrideList],\n)\n@inject\nasync def patch_validation_overrides_endpoint(\n    resource_id: Annotated[str, Depends(get_resource_id)],\n    overrides: Annotated[\n        list[ValidationOverrideInput],\n        Body(\n            title=\"Validation override input.\",\n            description=\"Override filters and updates\",\n        ),\n    ],\n    user: Annotated[UserOutput, Depends(check_curator_role)],\n    validation_override_service: ValidationOverrideService = Depends(\n        Provide[\"services.validation_override_service\"]\n    ),\n):\n    if not overrides:\n        return APIErrorResponse(error_message=\"No overrides.\")\n\n    logger.info(\n        \"Override patch request for %s from user %s: %s\",\n        resource_id,\n        user.id_,\n        [x.model_dump_json() for x in overrides],\n    )\n    overrides = await patch_validation_overrides(\n        resource_id=resource_id,\n        validation_overrides=overrides,\n        validation_override_service=validation_override_service,\n    )\n</code></pre> <p>Service usage in application layer</p> <p>Dependency wiring is not used in application layer (except async tasks). Any business method or class uses only interfaces.</p> <pre><code>async def patch_validation_overrides(\n    resource_id: str,\n    validation_override: ValidationOverrideInput,\n    validation_override_service: ValidationOverrideService,\n) -&gt; ValidationOverrideList:\n    repo = validation_override_service\n    overrides_content = await repo.get_validation_overrides(resource_id=resource_id)\n    version = overrides_content.validation_version\n</code></pre>"},{"location":"design/aspects/dependency_inversion/#dependency-injection-to-call-async-tasks","title":"Dependency injection to call async tasks","text":"<p>Example</p> <p>Async tasks are defined in <code>application</code> layer and can be called from <code>application</code> or <code>presentation</code> layer. They are entrypoints to run remote tasks on remote workers, so async tasks can define parameters to be injected by dependency injection mechanism.</p> <p>The following example shows an example usage of dependency injection in async tasks.</p> <p>///</p> <pre><code>import logging\nfrom typing import Union\n\nfrom dependency_injector.wiring import Provide, inject\n\nfrom mtbls.application.decorators.async_task import async_task\nfrom mtbls.application.remote_tasks.common.run_validation import (\n    run_validation_task,\n    run_validation_task_with_modifiers,\n)\nfrom mtbls.application.remote_tasks.common.utils import run_coroutine\nfrom mtbls.application.services.interfaces.async_task.async_task_result import (\n    AsyncTaskResult,\n)\nfrom mtbls.application.services.interfaces.policy_service import PolicyService\nfrom mtbls.application.services.interfaces.study_metadata_service_factory import (\n    StudyMetadataServiceFactory,\n)\nfrom mtbls.domain.shared.validator.types import ValidationPhase\n\nlogger = logging.getLogger(__name__)\n\n\n@async_task(queue=\"common\")\n@inject\ndef run_validation(  # noqa: PLR0913\n    *,\n    resource_id: str,\n    apply_modifiers: bool = True,\n    phases: Union[ValidationPhase, None, list[str]] = None,\n    serialize_result: bool = True,\n    study_metadata_service_factory: StudyMetadataServiceFactory = Provide[\n        \"services.study_metadata_service_factory\"\n    ],\n    policy_service: PolicyService = Provide[\"services.policy_service\"],\n    **kwargs,\n) -&gt; AsyncTaskResult:\n    try:\n        modifier_result = None\n        if apply_modifiers:\n            coroutine = run_validation_task_with_modifiers(\n                resource_id,\n                study_metadata_service_factory=study_metadata_service_factory,\n                policy_service=policy_service,\n                phases=phases,\n                serialize_result=serialize_result,\n            )\n        else:\n            coroutine = run_validation_task(\n                resource_id,\n                modifier_result=modifier_result,\n                study_metadata_service_factory=study_metadata_service_factory,\n                policy_service=policy_service,\n                phases=phases,\n                serialize_result=serialize_result,\n            )\n        return run_coroutine(coroutine)\n    except Exception as ex:\n        logger.error(\"Validation task execution for %s failed.\", resource_id)\n        logger.exception(ex)\n        raise ex\n    finally:\n        logger.info(\"Validation task execution for %s ended.\", resource_id)\n</code></pre>"},{"location":"design/aspects/dependency_inversion/#unit-tests-and-overridden-dependency-containers","title":"Unit tests and overridden dependency containers","text":"<p>Example</p> <p>You can override containers any time but the most common case is unit tests.</p> <p>The following example shows an example how to override a container to use:</p> <ul> <li>local database</li> <li>in-memory cache</li> <li>standalone authentication service</li> </ul> <p>It also overrides configuration file to fetch configurations of local database, in-memory cache and standalone authentication service.</p> <pre><code>from mtbls.application.services.interfaces.http_client import HttpClient\nfrom mtbls.infrastructure.auth.standalone.standalone_authentication_config import (\n    StandaloneAuthenticationConfiguration,\n)\nfrom mtbls.infrastructure.auth.standalone.standalone_authentication_service import (\n    AuthenticationServiceImpl,\n)\nfrom mtbls.infrastructure.caching.in_memory.in_memory_cache import InMemoryCacheImpl\nfrom mtbls.infrastructure.system_health_check_service.standalone.standalone_system_health_check_config import (  # noqa E501\n    StandaloneSystemHealthCheckConfiguration,\n)\nfrom mtbls.infrastructure.system_health_check_service.standalone.standalone_system_health_check_service import (  # noqa E501\n    StandaloneSystemHealthCheckService,\n)\nfrom mtbls.run.rest_api.submission.containers import Ws3ApplicationContainer\nfrom tests.mtbls.mocks.policy_service.mock_policy_service import MockPolicyService\n\n\n@pytest.fixture(scope=\"module\")\ndef submission_api_container(local_env_container) -&gt; Ws3ApplicationContainer:\n    container = local_env_container\n    standalone_heath_check_config_str = (\n        container.config.services.system_health_check.standalone()\n    )\n    health_check_config = StandaloneSystemHealthCheckConfiguration.model_validate(\n        standalone_heath_check_config_str\n    )\n    container.gateways.http_client.override(Mock(spec=HttpClient))\n\n    container.services.system_health_check_service.override(\n        StandaloneSystemHealthCheckService(\n            config=health_check_config, http_client=container.gateways.http_client\n        )\n    )\n    # Override Cache\n    container.services.cache_service.override(InMemoryCacheImpl())\n    # Override Authentication service\n    standalone_auth_config_str = container.config.services.authentication.standalone()\n    standalone_auth_config = StandaloneAuthenticationConfiguration.model_validate(\n        standalone_auth_config_str\n    )\n    container.services.authentication_service.override(\n        AuthenticationServiceImpl(\n            config=standalone_auth_config,\n            cache_service=container.services.cache_service(),\n            user_read_repository=container.repositories.user_read_repository(),\n        )\n    )\n\n    container.services.policy_service.override(MockPolicyService())\n\n    return container\n</code></pre>"},{"location":"design/aspects/logging/","title":"Logging","text":"<p>Logging mechanism is based on Python logging module. It is extended to implement the following logging requirements:</p> <ul> <li>Each log will be traceable to identify time, requester, source IP, endpoint and requested resource (MTBLS, REQ)</li> <li>Each log has a request id to find all logs triggered by the same request.</li> <li>Each async task will log with the task id.</li> <li>Logs will not contain personal credentials or PII (Personally Identifiable Information)</li> </ul>"},{"location":"design/aspects/logging/#general-design-and-coding-principles","title":"General design and coding principles","text":"<ul> <li>Each module uses its own logger (logger with <code>__name__</code> ) to log its state and progress.</li> <li>Use logging module instead of <code>print</code> lines.</li> <li>Do not log any secret (password, token, etc.)</li> <li>Prefer logging statement deferred string formatting instead of f-string or string format.</li> <li>Create a log filter for each executable and update it to filter unexpected or more frequent logs (version, health check, etc.).</li> <li>Resource id (MTBLS, REQ, etc.), IP, user, path, etc. will be injected in logs. Do not add these values in log messages.</li> </ul> <pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\nindex = 1\nvalue = \"data\"\n\nlogger.error(\"Error at %s: %s\", index, value)\n\n# instead of\nlogger.error(f\"Error at {index}: {value}\")\n# or\nlogger.error(\"Error at {}: {}\".format(index, value))\n</code></pre> <p>Hint</p> <p>These design principles will be checked with linter automatically.</p>"},{"location":"design/aspects/logging/#logging-configuration","title":"Logging configuration","text":"<p>Each application can have custom logging configuration and logging filter classes.</p> <p>Logging configurations have both <code>json</code> and <code>text</code> formatters. Each formatter can also print some additional information for each log:</p> <ul> <li><code>resource_id</code> to track requested resource (MTBLS or REQ id)</li> <li><code>user_id</code> to track authenticated user. Its value is unique user id (not email or user id) in user database table.</li> <li><code>route path</code> to track target REST API endpoint or method.</li> <li><code>request_id</code> to track all logs triggered by the same request.</li> <li><code>task_id</code> to track all async task logs triggered by the same task</li> <li><code>client</code> to track IP address or host of the requester</li> </ul> <p>An example logging configuration is below:</p> <pre><code>logging:\n  version: 1\n  disable_existing_loggers: true\n  formatters:\n    json_formatter:\n      format: '{ \"level_name\": \"%(levelname)s\", \"time\": \"%(asctime)s\",  \"client\": \"%(client)s\",  \"path\": \"%(route_path)s\", \"resource_id\": \"%(resource_id)s\", \"user\": %(user_id)d, \"request_id\": \"%(request_id)s\", \"name\": \"%(name)s\", \"message\": \"%(message)s\" }'\n    text_formatter:\n      format: '%(levelname)-8s %(asctime)s %(user_id)d %(client)s %(route_path)s %(resource_id)s %(request_id)s %(name)s \"%(message)s\"'\n  handlers:\n    console:\n      class: \"logging.StreamHandler\"\n      level: DEBUG\n      formatter: \"text_formatter\"\n      stream: \"ext://sys.stdout\"\n      filters: [ default_filter, correlation_id ]\n  root:\n    level: DEBUG\n    handlers: [ \"console\" ]\n    propogate: true\n  loggers:\n    mtbls:\n      level: DEBUG\n      propogate: yes\n  filters:\n    correlation_id:\n      (): \"asgi_correlation_id.CorrelationIdFilter\"\n      default_value: \"-\"\n    default_filter:\n      (): \"mtbls.run.rest_api.submission.log_filter.DefaultLogFilter\"\n</code></pre> <p>Example JSON log</p> <pre><code>{ \"level_name\": \"DEBUG\", \"time\": \"2024-12-22 18:39:02,218\",  \"client\": \"127.0.0.1\",  \"path\": \"/auth/v1/token\", \"resource_id\": \"-\", \"user\": 0, \"request_id\": \"60335885-b4a0-486b-bc77-2bfa52ebaf2f\", \"name\": \"mtbls.presentation.rest_api.core.authorization_middleware\", \"message\": \"Unauthenticated user requests POST /auth/v1/token from host/IP 127.0.0.1.\" }\n{ \"level_name\": \"INFO\", \"time\": \"2024-12-22 18:39:02,239\",  \"client\": \"127.0.0.1\",  \"path\": \"/auth/v1/token\", \"resource_id\": \"-\", \"user\": 0, \"request_id\": \"60335885-b4a0-486b-bc77-2bfa52ebaf2f\", \"name\": \"mtbls.infrastructure.auth.mtbls_ws2.authentication.mtbls_ws2_proxy\", \"message\": \"Login request from: help@ebi.ac.uk\" }\n{ \"level_name\": \"INFO\", \"time\": \"2024-12-22 18:39:02,370\",  \"client\": \"127.0.0.1\",  \"path\": \"/auth/v1/token\", \"resource_id\": \"-\", \"user\": 0, \"request_id\": \"60335885-b4a0-486b-bc77-2bfa52ebaf2f\", \"name\": \"uvicorn.access\", \"message\": \"127.0.0.1:51279 - \"POST /auth/v1/token HTTP/1.1\" 200\" }\n{ \"level_name\": \"DEBUG\", \"time\": \"2024-12-22 18:39:16,340\",  \"client\": \"127.0.0.1\",  \"path\": \"/submissions/v1/investigation-files/MTBLS60\", \"resource_id\": \"MTBLS60\", \"user\": 25432, \"request_id\": \"54eb7ab4-675c-4ee7-8637-819fdf876105\", \"name\": \"mtbls.presentation.rest_api.core.authorization_middleware\", \"message\": \"User 25432 requests GET /submissions/v1/investigation-files/MTBLS60 from host/IP 127.0.0.1. Target resource id: MTBLS60\" }\n{ \"level_name\": \"DEBUG\", \"time\": \"2024-12-22 18:39:16,340\",  \"client\": \"127.0.0.1\",  \"path\": \"/submissions/v1/investigation-files/MTBLS60\", \"resource_id\": \"MTBLS60\", \"user\": 25432, \"request_id\": \"54eb7ab4-675c-4ee7-8637-819fdf876105\", \"name\": \"mtbls.presentation.rest_api.groups.auth.v1.routers.dependencies\", \"message\": \"User 25432 is granted to update resource MTBLS60\" }\n{ \"level_name\": \"INFO\", \"time\": \"2024-12-22 18:39:16,890\",  \"client\": \"127.0.0.1\",  \"path\": \"/submissions/v1/investigation-files/MTBLS60\", \"resource_id\": \"MTBLS60\", \"user\": 25432, \"request_id\": \"54eb7ab4-675c-4ee7-8637-819fdf876105\", \"name\": \"uvicorn.access\", \"message\": \"127.0.0.1:51283 - \"GET /submissions/v1/investigation-files/MTBLS60 HTTP/1.1\" 200\" }\n</code></pre> <p>A <code>RequestTracker</code> object is created for each request automatically. Custom logging filters defined in logging configuration inject additional information using the <code>RequestTracker</code> object for the request.</p> <pre><code>from logging import Filter, LogRecord\n\nfrom mtbls.application.context.request_tracker import (\n    RequestTracker,\n    get_request_tracker,\n)\n\nclass DefaultLogFilter(Filter):\n    #...\n\n    def filter(\n        self,\n        record: LogRecord,\n    ) -&gt; bool:\n        #...\n        context_vars = get_request_tracker()\n        if context_vars and isinstance(context_vars, RequestTracker):\n            model = context_vars.get_request_tracker_model()\n            record.user_id = model.user_id\n            record.route_path = model.route_path\n            record.resource_id = model.resource_id\n            record.client = model.client\n            record.request_id = model.request_id\n            record.task_id = model.task_id\n        else:\n            record.user_id = 0\n            record.route_path = \"-\"\n            record.resource_id = \"-\"\n            record.client = \"-\"\n            record.request_id = \"-\"\n            record.task_id = \"-\"\n\n        return True\n</code></pre>"},{"location":"design/aspects/logging/#management-of-additional-logging-information","title":"Management of additional logging information","text":"<ul> <li> <p>REST API executables: <code>AuthorizationMiddleware</code> updates additional information.</p> </li> <li> <p>Async Task Workers:</p> </li> <li> <p>Async task executor adds <code>request_tracker</code> parameter with <code>RequestTracker</code> data.</p> </li> <li>Before starting async task execution on remote worker, <code>request_tracker</code> parameter is checked and updates additional information.</li> </ul> <pre><code>class CeleryAsyncTaskExecutor(AsyncTaskExecutor):\n    def __init__(\n        self, task_method: Callable, task_name: str, id_generator: IdGenerator, **kwargs\n    ):\n        self.task_method = task_method\n        self.kwargs = kwargs\n        self.task_name = task_name\n        self.id_generator = id_generator\n\n    async def start(self, expires: Union[None, int] = None) -&gt; AsyncTaskResult:\n        request_tracker = get_request_tracker().get_request_tracker_model().model_dump()\n        self.kwargs[\"request_tracker\"] = request_tracker\n        if self.id_generator:\n            task_id = self.id_generator.generate_unique_id()\n            task = self.task_method.apply_async(\n                expires=expires,\n                kwargs=self.kwargs,\n                task_id=task_id,\n            )\n        else:\n            task = self.task_method.apply_async(expires=expires, kwargs=self.kwargs)\n        logger.info(\"Task '%s' is created.\", self.task_name)\n        return CeleryAsyncTaskResult(task)\n</code></pre> <pre><code>class CeleryBaseTask(celery.Task):\n    def on_failure(self, exc, task_id, args, kwargs, einfo):\n        logger.error(\"%s failed: %s\", task_id, str(exc))\n\n    def before_start(self, task_id, args, kwargs):\n        request_tracker = get_request_tracker()\n        request_tracker.task_id_var.set(task_id)\n        if \"request_tracker\" in kwargs:\n            request_tracker_dict = kwargs[\"request_tracker\"]\n</code></pre>"},{"location":"development/general/","title":"General","text":"<ul> <li>Python <code>pathlib.Path</code> package is used instead of <code>os.path</code></li> </ul>"}]}