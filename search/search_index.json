{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#metabolights-ws3","title":"MetaboLights Ws3","text":"<p>The <code>mtbls-ws3</code> is Python application stack to manage MetaboLights open repository. It provides REST API endpoints for the metabolomics community and other MetaboLights applications.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>REST API endpoints with FastAPI and API documentation (Redoc).</li> <li>Json serializable models with pydantic library.</li> <li>Serve the selected REST API endpoints (e.g., submission, curation, public, etc.).</li> <li>A new design with best practices, including dependency inversion, testability, modularity, maintainability, and extensibility.</li> <li>Jwt based extensible authentication, authorization, identity management</li> <li>Improved logging mechanism</li> </ul>"},{"location":"design/architecture/","title":"Overview","text":"<p>MetaboLights WS3 is designed to address the latest goals and requirements of MetaboLights.</p> <ul> <li><code>Separation of Concerns</code>: Different concerns (presentation , business logic and data access) should be isolated each other. Especially, business logic does not need to know how  data is stored or managed.</li> <li><code>Maintainability</code>: Architecture should enable more maintainable code. To achieve this, Well defined layers should be maintained based on separation of concerns instead of external framework dependent spaghetti code. Layers and layer dependencies should be checked automatically.</li> <li><code>Framework Independence</code>: Business logic should not depend on external frameworks to make it easy to upgrade them or use different frameworks without affecting remaining code. MetaboLights uses different frameworks and external services and over the years, any dependencies cause major issues for applications upgrades or infrastructure changes.</li> <li><code>Testability</code>: Architecture should enable to change application configuration and run unit, integration, functional and non-functional tests.</li> <li><code>Extensible</code>: Architecture should enable to add new components or new frameworks.</li> <li><code>Flexible</code>: Architecture can enable to define and run different applications (multiple REST API servers, CLI applications) on same repository.</li> <li><code>Scalable</code>: Each application should run as stateless  and can be deployed in a container.</li> </ul> <p>Inspiration</p> <p>MetaboLights WS3 is inspired from the following software principals, architectures and approaches:</p> <ul> <li>SOLID (Single-responsibility, Open-closed Principle, Liskov substitution, Interface segregation, Dependency inversion) Object Oriented Design Principles</li> <li>Domain Driven Design (DDD)</li> <li>Command Query Responsibility Segregation (CQRS)</li> <li>Clean Architecture</li> <li>Onion Architecture</li> <li>Hexagonal / Port &amp; Adaptor Architecture</li> </ul>"},{"location":"design/architecture/#metabolights-ws3-architecture","title":"MetaboLights Ws3 Architecture","text":"<p>MetaboLights Ws3 architecture has  <code>domain</code>, <code>application</code>, <code>presentation</code> and <code>infrastructure</code> core layers, and an additional layer named <code>run</code> to customize endpoints and executables. You can find its layers and their dependency hierarchy below:</p> <p></p>"},{"location":"design/architecture/#general-design-principles","title":"General design principles","text":"<ul> <li>Each layer can use the lower layer(s) but not higher layers. For example, <code>infrastructure</code> layer can import both <code>application</code> and <code>domain</code> layer modules but <code>application</code> layer can only import modules from <code>domain</code> layer.</li> <li><code>infrastructure</code> and <code>presentation</code> layers are on the same level and they are isolated. They do not import any modules from each other.</li> <li>All external services (e.g., external web services) and python package dependencies (postgresql, redis, elasticsearch, etc.) are isolated from <code>application</code> layer modules. Application modules only use interfaces. Interfaces are implemented in <code>infrastructure</code> layer.</li> <li><code>application</code> layer modules do not know how domain entities are stored and managed (on NFS, SQL or NoSQL DB, Object Storage, etc.). They use only repository interfaces to process them.</li> <li>Only <code>presentation</code> layer modules will check authentication or authorization (Role based authentication and authorization). There will be no logic to check authentication or authorization in <code>application</code> or <code>infrastructure</code> layer modules (They may access authentication and authorization information in read-only mode).</li> <li>All application logic should be implemented in <code>application</code> layer not in <code>presentation</code> or <code>infrastructure</code> layer.</li> <li><code>presentation</code> layer modules should implement only RestAPI or CLI inputs and outputs (authentication and authorization). Any business logic should be moved to application and domain layer.</li> <li>Implementation layer modules should implement only application interfaces.</li> <li>Any external python package used in <code>presentation</code> or <code>infrastructure</code> layer is defined as an optional dependency (group).</li> <li>An <code>extra</code> dependency name is defined for each executable defined in <code>run</code> layer <pre><code>[tool.poetry.extras]\nws3_worker = [\"uvloop\", \"celery\", \"httpx\", \"sqlalchemy\", \"asyncpg\", \"metabolights-utils\", \"redis\"]\n</code></pre></li> <li><code>dependency_injector</code> containers will be defined for each executable in <code>run</code> layer.</li> <li>Prefer to implement and use async coroutines for time consuming operations (external service calls, time consuming tasks etc.)</li> </ul>"},{"location":"design/architecture/#layers-and-design-principles","title":"Layers and design principles","text":""},{"location":"design/architecture/#domain-layer","title":"Domain layer","text":"<p>Domain layer contains only MetaboLights specific domain classes, enumerations, decorators, exceptions and basic utility methods.</p> <ul> <li><code>Domain</code> layer imports only <code>core Python packages</code> and the following libraries:<ul> <li><code>pydantic</code></li> <li><code>metabolights-utils</code></li> <li>Core utility libraries: <code>pyyaml</code>, <code>python-dateutil</code>, <code>pytz</code></li> </ul> </li> </ul>"},{"location":"design/architecture/#application-layer","title":"Application layer","text":"<ul> <li> <p><code>Application</code> layer imports only <code>domain</code> layer packages. The only exception is async tasks in <code>application</code> layer. They use <code>dependency_injector</code> package for injection of services.</p> </li> <li> <p>All methods and classes in <code>application</code> layer use interfaces to access infrastructure components and services.</p> </li> <li> <p><code>Application</code> layer modules do not import any external python libraries (e.g., celery, redis, etc.) in. Instead of importing any external library, a new service or component may be defined in <code>infrastructure</code> layer. To implement a new service or component:</p> <ul> <li>Define interfaces in <code>application</code> layer.</li> <li>Create any required domain objects in <code>domain</code> layer.</li> <li>Implement interfaces in <code>infrastructure</code> layer.</li> <li>Update <code>dependency_injector</code> container in <code>run</code> layer to use it.</li> </ul> </li> <li>Initial interfaces in <code>application</code> layers are listed below:<ul> <li><code>AsyncTaskService</code></li> <li><code>AuthenticationService</code>, <code>AuthorizationService</code> and <code>IdentityService</code></li> <li><code>CacheService</code></li> <li><code>PolicyService</code></li> <li><code>StudyMetadataService</code></li> </ul> </li> <li>Repositories are also defined as interfaces. e.g. <code>Study</code>, <code>User</code>, <code>ValidationReport</code>, <code>ValidationOverride</code>, <code>StudyObject</code>, etc. entity repositories.</li> <li>Application related logic is implemented in <code>use_cases</code> package. any module in <code>use_cases</code> package can import any other packages in <code>application</code> layer.</li> <li>All async tasks are implemented in <code>remote_tasks</code> package and they do not import <code>use_cases</code> modules.</li> </ul> <p>You can find <code>application</code> layer packages and their dependency hierarchy below:</p> <p></p>"},{"location":"design/architecture/#presentation-layer","title":"Presentation layer","text":"<ul> <li><code>Presentation</code> layer can imports <code>application</code> and <code>domain</code> layer packages. It may also import <code>dependency_injector</code> and presentation related libraries (e.g., FastAPI, click).</li> <li><code>Presentation</code> layer do not import any <code>infrastructure</code> layer packages in <code>presentation</code> layer.</li> <li>Rest API, CLI or other executable can be defined as a presentation.</li> <li>Rest API endpoints are defined within API groups and each API group has managed versions. Initial Rest API groups are <code>submission</code>,<code>auth</code>, <code>curation</code>,  <code>submission</code>, and <code>public</code> .<ul> <li><code>Submission Rest API group</code>: It provides endpoints to create and update MetaboLights submissions. Authentication is required to use endpoints.</li> <li><code>Curation Rest API group</code>: It provides endpoints to curators to run curation tasks on submitted studies and make them public. Authentication is required to use endpoints.</li> <li><code>Public Rest API group</code>: It provides endpoints to access MetaboLights studies.</li> <li><code>Auth Rest API group</code>: It provides to endpoints to create and revoke JWT tokens.</li> </ul> </li> <li>Each user or service that wants to access any authorized endpoints should have a valid JWT token. Only JWT token is used to authorize requests.</li> <li>Rest API authentication will be managed within authorization middleware.</li> </ul>"},{"location":"design/architecture/#infrastructure-layer","title":"Infrastructure layer","text":"<ul> <li><code>Infrastructure</code> layer modules can import <code>dependency_injector</code> and any external libraries (e.g., redis, elasticsearch, celery, etc.) as well as <code>application</code> and <code>domain</code> layer.</li> <li><code>Infrastructure</code> layer modules do not import any <code>presentation</code> layer modules.</li> <li>Multiple implementations can be defined for an interface defined in <code>application</code> layer. For example, there are proxy and standalone implementations for auth services. Each implementation is isolated from each others.</li> <li>Initial Service and repository implementations:<ul> <li>AsyncTaskService: <code>Celery</code> and <code>thread</code> (for development) implementations</li> <li>AuthenticationService, AuthorizationService and IdentityService: <code>mtbls_ws2 proxy</code> and <code>standalone</code> implementations.</li> <li>CacheService: <code>Redis</code>, <code>Redis sentinel</code> and <code>in-memory</code> (for development) implementations</li> <li>PolicyService: Open policy agency (<code>OPA</code>) implementation</li> <li>StudyMetadataService: <code>NFS</code> and <code>mongodb</code> (in progress) implementations</li> <li>ValidationOverrideService, ValidationReportService: <code>NFS</code> and <code>mongodb</code> (in progress) implementations</li> <li>Repositories:<ul> <li><code>Study</code>, <code>Submitter</code>: <code>postgresql</code> and <code>sqlite</code> (for development) implementations</li> <li><code>ValidationReport</code>, <code>ValidationOverride</code>: <code>NFS</code> and <code>mongodb</code> (in progress)</li> <li><code>InvestigationFileObject</code>, <code>IsaTableObject</code> (<code>SampleFile</code>, <code>AssayFile</code> <code>AssignmentFile</code>): <code>NFS</code> and <code>mongodb</code> (in progress)</li> <li><code>FileObject</code>:  to store data folder content. <code>mongodb</code> (in progress)</li> </ul> </li> </ul> </li> </ul>"},{"location":"design/architecture/#run-layer","title":"Run layer","text":"<ul> <li><code>Run</code> layer defines <code>dependency_injector</code> container and runs executable in <code>presentation</code> layer (submission API, public API, worker, etc.).</li> <li>Initial executables are:<ul> <li><code>Submission Rest API</code>: It uses celery async application, NFS and PostgreSQL based repositories, redis cache service and proxy authentication service.</li> <li><code>Submission Rest API Worker</code>: Celery worker to run submission remote tasks</li> <li><code>Submission Rest API Worker Monitor</code>: Flower executable to monitor celery tasks</li> </ul> </li> <li>Log filters and application configuration files are customized depends on selected presentation layer application and service implementations.</li> <li>Unit tests overrides async task, auth, and cache services. Postgresql database is also overriden by Sqlite database to run unit tests.</li> </ul>"},{"location":"design/aspects/async_tasks/","title":"Async and Remote Tasks","text":"<p>Async task is an entry point method to run on another server or process. There are two implementations:</p> <ul> <li><code>Celery</code>: Celery workers process the tasks</li> <li><code>Threading</code>: Tasks run in a thread (local development only)</li> </ul> <p>Async tasks should be decorated with <code>@async_task</code> and registered before starting application.</p> <pre><code>modules = find_async_task_modules(app_name=app_name, queue_names=queue_names)\nasync_task_modules = load_modules(modules, module_config)\n</code></pre> <pre><code>async_task_service: AsyncTaskService = providers.Singleton(\n    CeleryAsyncTaskService,\n    broker=gateways.pub_sub_broker,\n    backend=gateways.pub_sub_backend,\n    app_name=\"default\",\n    queue_names=[\"common\", \"validation\", \"datamover\", \"compute\", \"\"],\n    async_task_registry=core.async_task_registry,\n)\n</code></pre>"},{"location":"design/aspects/auth/","title":"Authentication, Authorization and Identity Management","text":"<p>User authentication will be managed centrally for Rest API endpoints. Endpoints can check authentication information (authenticated or unauthenticated) to apply business rules (e.g. submitters can update study status if study is validated.)</p>"},{"location":"design/aspects/auth/#general-design-and-coding-principles","title":"General design and coding principles","text":"<ul> <li>Authentication can be completed with username/password or user API token. After authentication, a new JWT token will be created and shared with user.</li> <li>Users use the generated JWT tokens to access restricted endpoints.</li> <li>JWT tokens will be validated by authentication service. Neither other services nor endpoints will check JWT token.</li> <li>Authenticated or unauthenticated user information  will be stored in request context. Other services or endpoints can access it.</li> <li>If a request has a JWT token and it is not valid (e.g. invalid format, expired, etc.), authentication service will return error message.</li> <li>If the requested path contains resource id (MTBLS, REQ), authorization service checks permissions for the user. Other services or endpoints can access permission.</li> </ul>"},{"location":"design/aspects/auth/#authentication","title":"Authentication","text":"<p>Authentication service methods are shown below. Implementations should support at least  JWT_TOKEN token and username/password authentications. Default implementatations are listed below:</p> <ul> <li><code>standalone</code>: Create and check JWT tokens. User information is fetched from database.</li> <li><code>mtbls_ws2</code>: It is a proxy service and use mtbls_ws2 endpoints for authentications.</li> </ul> <pre><code>class AuthenticationService(abc.ABC):\n    @abc.abstractmethod\n    async def authenticate_with_token(self, token_type: TokenType, token: str) -&gt; str:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    async def authenticate_with_password(self, username: str, password: str) -&gt; str:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    async def revoke_jwt_token(self, jwt: str) -&gt; str:\n        raise NotImplementedError()\n\n    @abc.abstractmethod\n    async def validate_token(self, token_type: TokenType, token: str) -&gt; str:\n        raise NotImplementedError()\n</code></pre> <p>Authentication service is used by a middleware service, and UnauthenticatedUser / AuthenticatedUser object is injected to request.</p> <pre><code>class AuthBackend(AuthenticationBackend):\n    def __init__(\n        self,\n        authentication_service: AuthenticationService,\n        user_read_repository: UserReadRepository,\n    ):\n        self.authentication_service = authentication_service\n        self.user_read_repository = user_read_repository\n\n    async def authenticate(self, conn):\n        if \"Authorization\" not in conn.headers:\n            return AuthCredentials({\"unauthenticated\"}), UnauthenticatedUser()\n\n        auth = conn.headers[\"Authorization\"]\n\n        username = await self.validate_credential(auth)\n\n        if not username:\n            return AuthCredentials({\"unauthenticated\"}), UnauthenticatedUser()\n        user: UserOutput = await self.user_read_repository.get_user_by_username(\n            username\n        )\n        if not user:\n            logger.error(\n                \"User role check failure. \"\n                \"User %s details are not fetched by from database.\",\n                username,\n            )\n            raise AuthenticationError(\"User details are not fetched from database\")\n        scopes = {\"authenticated\"}\n        if user.role == UserRole.SUBMITTER:\n            scopes.add(\"submitter\")\n        elif user.role == UserRole.CURATOR:\n            scopes.add(\"curator\")\n            scopes.add(\"submitter\")\n        elif user.role == UserRole.SYSTEM_ADMIN:\n            scopes.add(\"admin\")\n\n        return AuthCredentials(scopes), AuthenticatedUser(user)\n</code></pre> <p>Each endpoint can check UnauthenticatedUser / AuthenticatedUser object. if only authorized users can access, endpoint should raise <code>AuthenticationError</code> exception.</p> <pre><code>async def check_read_permission(\n    resource_id: Annotated[str, RESOURCE_ID_IN_PATH],\n    jwt_token: Union[None, str] = Security(oauth2_scheme.oauth2_scheme),\n    request: Request = None,\n) -&gt; StudyPermissionContext:\n    get_request_tracker().resource_id_var.set(resource_id if resource_id else \"-\")\n    if isinstance(request.user, AuthenticatedUser):\n        context = request.user.permission_context\n        if not context or not context.study or not context.permissions.read:\n            logger.warning(\n                \"User %s is not granted to view resource %s\",\n                context.user.id_,\n                resource_id,\n            )\n            raise AuthorizationError(\n                f\"User {context.user.id_} is not granted to view resource {resource_id}\"\n            )\n        logger.debug(\n            \"User %s is granted to view resource %s\",\n            context.user.id_,\n            resource_id,\n        )\n        return context\n    logger.warning(\n        \"Unauthenticated user %s is granted to view resource %s\",\n        resource_id,\n    )\n    raise AuthenticationError(\"User has not authenticated.\")\n</code></pre>"},{"location":"design/aspects/auth/#authorization","title":"Authorization","text":"<p>The authorization service determines the user's permissions for the requested resource (MTBLSxxx or REQxxx) and can be used by any endpoint.</p> <p><pre><code>class AuthorizationService(abc.ABC):\n    @abc.abstractmethod\n    async def get_permissions(\n        self,\n        username: Union[None, str],\n        resource_id: str,\n        sub_resource: Union[None, str] = None,\n    ) -&gt; StudyPermissionContext: ...\n\n    @abc.abstractmethod\n    async def get_user_resource_permission(\n        self,\n        user: Union[None, UserOutput],\n        resource_id: str,\n        sub_resource: Union[None, str] = None,\n    ) -&gt; StudyPermissionContext: ...\n</code></pre> It returns <code>StudyPermissionContext</code> object that defines all possible user's permissions (read, write, delete, create).</p> <pre><code>class ResourcePermission(BaseModel):\n    create: bool = False\n    read: bool = False\n    update: bool = False\n    delete: bool = False\n\n\nclass PermissionContext(abc.ABC, BaseModel, Generic[T, R]):\n    user: Union[None, T] = None\n    is_owner: bool = False\n    study: Union[None, R] = None\n    permissions: ResourcePermission = ResourcePermission()\n    parameters: dict[str, Any] = {}\n\n\nclass StudyPermissionContext(PermissionContext[UserOutput, StudyOutput]): ...\n</code></pre> <p>If there is a resource_id (or study_id) in the requested path (/../MTBLS1/..), <code>AuthorizationMiddleware</code> updates permission_context field of UnauthenticatedUser / AuthenticatedUser in request. Endpoints that include a resource_id in the request path can use it directly without requiring the authorization service. <code>AuthorizationMiddleware</code> also can check request paths and authorize request. If user has no permission to access the requested resource, <code>AuthorizationMiddleware</code> raises <code>AuthorizationError</code>. Path prefixes and allowed roles can be defined in configuration file.</p> <p>Path Authorization Example</p> <p>All endpoints starting with /submissions/ are restricted to users with the 'curator' or 'submitter' roles (some 'READ' exceptions if resource is public). Endpoints starting with /curation/ are accessible only to curators.</p> <pre><code>    authorized_endpoints:\n    - prefix: \"/submissions/\"\n      scopes:\n      - curator\n      - submitter\n    - prefix: \"/curation/\"\n      scopes:\n      - curator\n</code></pre>"},{"location":"design/aspects/auth/#identity-management","title":"Identity Management","text":"<p>User identities (username, password hash, role etc.) are stored on database.</p>"},{"location":"design/aspects/configuration/","title":"Configuration","text":"<p>Application configurations will be defined in yaml file(s) and managed by dependency injection mechanism.</p>"},{"location":"design/aspects/configuration/#general-design-and-coding-principles","title":"General design and coding principles","text":"<ul> <li>The content and structure of a configuration file depend on the application's dependency container and selected service/repository implementations.</li> <li>Application dependency container loads configuration file and uses its content to initiate container elements (resource, service, repository, etc.).</li> <li>Any configuration related to business logic can be defined in config file. They can be injected by dependency injection mechanism.</li> </ul> <p>Example</p> <p>The following example loads <code>config.yaml</code> file and sets it to core container. Core container uses <code>run.submission.logging</code> sub element.</p> <p>On the other hand, Only <code>gateways</code> sub element of config file is set to gateways container and gateway container uses <code>gateways.database.postgresql.connection</code> sub element of config file.</p> <p>Example Configuration File</p> <pre><code>gateways:\n  ...\n  database:\n    postgresql:\n      connection:\n        host: remote-host\n        port: 32069\n        user: test\n        password: {{ postgresql.database }}\n        database: sample\n        url_scheme: postgresql+asyncpg\nrun:\n  ...\n  submission:\n    logging:\n      version: 1\n      disable_existing_loggers: true\n      formatters:\n        json_formatter:\n          format: '{ \"level_name\": \"%(levelname)s\", \"time\": \"%(asctime)s\",  \"client\": \"%(client)s\",  \"path\": \"%(route_path)s\", \"resource_id\": \"%(resource_id)s\", \"user\": %(user_id)d, \"request_id\": \"%(request_id)s\", \"name\": \"%(name)s\", \"message\": \"%(message)s\" }'\n        text_formatter:\n          format: '%(levelname)-8s %(asctime)s %(user_id)d %(client)s %(route_path)s %(resource_id)s %(request_id)s %(name)s \"%(message)s\"'\n      handlers:\n        console:\n          class: \"logging.StreamHandler\"\n          level: DEBUG\n          formatter: \"json_formatter\"\n          stream: \"ext://sys.stdout\"\n          filters: [ default_filter, correlation_id ]\n      root:\n        level: DEBUG\n        handlers: [ \"console\" ]\n        propogate: true\n      loggers:\n        mtbls:\n          level: DEBUG\n          propogate: yes\n      ...\n</code></pre> <p>Example Container Definition</p> <pre><code>class Ws3CoreContainer(containers.DeclarativeContainer):\n    config = providers.Configuration()\n\n    logging_config = providers.Resource(\n        logging_config.dictConfig,\n        config=config.run.submission.logging,\n    )\n    async_task_registry = providers.Resource(get_async_task_registry)\n\nclass GatewaysContainer(containers.DeclarativeContainer):\n    config = providers.Configuration()\n    database_client: DatabaseClient = providers.Singleton(\n        DatabaseClientImpl,\n        db_connection=config.database.postgresql.connection,\n        db_pool_size=runtime_config.db_pool_size,\n    )\n\nclass Ws3ApplicationContainer(containers.DeclarativeContainer):\n    config = providers.Configuration(yaml_files=[\"config.yaml\"])\n\n    core = providers.Container(\n        Ws3CoreContainer,\n        config=config,\n    )\n\n    gateways = providers.Container(\n        GatewaysContainer,\n        config=config.gateways,\n    )\n</code></pre>"},{"location":"design/aspects/configuration/#secrets","title":"Secrets","text":"<p>Secrets are stored in a different yaml file named <code>config-secrets.yaml</code>. They are referenced in config file as a template (e.g.<code>{{ postgresql.password }}</code> ) and rendered with <code>Jinja2</code> template framework.</p> <p>Each application should render config file after creating dependency container.</p> <pre><code>class Ws3ApplicationContainer(containers.DeclarativeContainer):\n    config = providers.Configuration(yaml_files=[\"config.yaml\"])\n    secrets = providers.Configuration(yaml_files=[\"config-secrets.yaml\"])\n    core = providers.Container(\n        Ws3CoreContainer,\n        config=config,\n    )\n\n...\n# initiate container and render secrets\ncontainer = Ws3ApplicationContainer()\ncontainer.init_resources()\nrender_config_secrets(container.config(), container.secrets())\n...\n</code></pre> <p>Example config.yaml</p> <pre><code>gateways:\n  ...\n  database:\n    postgresql:\n      connection:\n        host: remote-host\n        port: 32069\n        user: xyz\n        password: {{ postgresql.database }}\n        database: testdb\n        url_scheme: postgresql+asyncpg\n</code></pre> <p>Example config-secrets.yaml</p> <pre><code>redis:\n  password: redis_ws1\npostgresql:\n  password: test.123\nstandalone_authentication:\n  application_secret_key: application-test.123\n</code></pre>"},{"location":"design/aspects/dependency_inversion/","title":"Dependency Inversion","text":"<p>Dependency injection is a common practice to decrease coupling and increase cohesion. It has three main advantages:</p> <ul> <li><code>Flexibility</code>: It enables to develop loosely coupled components. An application can be extended or changed easily by using the components in a different way.</li> <li><code>Testability</code>: Mocks can be injected easily instead of real services or resources (a service or database, etc.).</li> <li><code>Maintainability</code>: Dependency injection helps to manage all dependencies. All components and dependencies defined explicitly in a container.</li> </ul>"},{"location":"design/aspects/dependency_inversion/#general-design-and-coding-principles","title":"General design and coding principles","text":"<ul> <li><code>dependency_injector</code> framework will be used for singleton, factory, configuration and resource  dependency injection capabilities.</li> <li>Dependency containers will be defined for each executable in <code>run</code> layer.</li> <li>Dependencies will be wired to only Rest API endpoints, async tasks and <code>run</code> layer modules. All others will not import dependency injection library need to define inputs to use interfaces managed in container.</li> </ul>"},{"location":"design/aspects/dependency_inversion/#dependency-containers","title":"Dependency containers","text":"<p>Any dependency container will be created for</p> <ol> <li>Selecting and defining service implementations and their dependencies (e.g. CacheService with RedisCacheService)</li> <li>Selecting and defining repository implementations and their dependencies for domain entities (postgreSQL, NFS, Mongo)</li> <li>Selecting and initiating application configuration (e.g. different config.yaml files for prod or development)</li> <li>Initiating application level variables and triggering global functions (logging configuration, async task registry, request tracker, etc.)</li> </ol> <p>Dependency container</p> <p>You can find an example container definition below. It defines repositories and their implementations. It also assigns the implementations' initiation parameters as well.</p> <pre><code>class RepositoriesContainer(containers.DeclarativeContainer):\n    config = providers.Configuration()\n    entity_mapper: EntityMapper = providers.Singleton(EntityMapper)\n\n    alias_generator: AliasGenerator = providers.Singleton(\n        DbTableAliasGeneratorImpl, entity_mapper\n    )\n\n    gateways = providers.DependenciesContainer()\n    services = providers.DependenciesContainer()\n    study_read_repository: StudyReadRepository = providers.Singleton(\n        SqlDbStudyReadRepository,\n        entity_mapper=entity_mapper,\n        alias_generator=alias_generator,\n        database_client=gateways.database_client,\n    )\n\n    user_write_repository: UserWriteRepository = providers.Singleton(\n        SqlDbUserWriteRepository,\n        entity_mapper=entity_mapper,\n        alias_generator=alias_generator,\n        database_client=gateways.database_client,\n    )\n\n    user_read_repository: UserReadRepository = providers.Singleton(\n        SqlDbUserReadRepository,\n        entity_mapper=entity_mapper,\n        alias_generator=alias_generator,\n        database_client=gateways.database_client,\n    )\n\n    study_file_repository: StudyFileRepository = providers.Singleton(\n        SqlDbStudyFileRepository,\n        entity_mapper=entity_mapper,\n        alias_generator=alias_generator,\n        database_client=gateways.database_client,\n    )\n\n    folder_manager = providers.Singleton(\n        StudyFolderManager, config=config.repositories.study_folders\n    )\n\n    internal_files_object_repository: FileObjectWriteRepository = providers.Singleton(\n        FileSystemObjectWriteRepository,\n        folder_manager=folder_manager,\n        study_bucket=StudyBucket.INTERNAL_FILES,\n        observer=study_file_repository,\n    )\n    audit_files_object_repository: FileObjectWriteRepository = providers.Singleton(\n        FileSystemObjectWriteRepository,\n        folder_manager=folder_manager,\n        study_bucket=StudyBucket.AUDIT_FILES,\n        observer=study_file_repository,\n    )\n    metadata_files_object_repository: FileObjectWriteRepository = providers.Singleton(\n        FileSystemObjectWriteRepository,\n        folder_manager=folder_manager,\n        study_bucket=StudyBucket.PRIVATE_METADATA_FILES,\n        observer=study_file_repository,\n    )\n</code></pre>"},{"location":"design/aspects/dependency_inversion/#dependency-injection-to-call-rest-api-endpoints","title":"Dependency injection to call Rest API endpoints","text":"<p>Example</p> <p>The following example shows how a dependency is injected into a Rest API endpoint.   Endpoint uses the injected service to call a business logic method in application layer</p> <pre><code>logger = getLogger(__file__)\n\nrouter = APIRouter(tags=[\"Study Validation Overrides\"], prefix=\"/curation/v1\")\n\n\n@router.patch(\n    \"/{resource_id}/validation-overrides\",\n    summary=\"Patch validation overrides for the study\",\n    description=\"Adds new override if it is not overrides list \",\n    response_model=APIResponse[ValidationOverrideList],\n)\n@inject\nasync def patch_validation_overrides_endpoint(\n    resource_id: Annotated[str, Depends(get_resource_id)],\n    overrides: Annotated[\n        list[ValidationOverrideInput],\n        Body(\n            title=\"Validation override input.\",\n            description=\"Override filters and updates\",\n        ),\n    ],\n    user: Annotated[UserOutput, Depends(check_curator_role)],\n    validation_override_service: ValidationOverrideService = Depends(\n        Provide[\"services.validation_override_service\"]\n    ),\n):\n    if not overrides:\n        return APIErrorResponse(error_message=\"No overrides.\")\n\n    logger.info(\n        \"Override patch request for %s from user %s: %s\",\n        resource_id,\n        user.id_,\n        [x.model_dump_json() for x in overrides],\n    )\n    overrides = await patch_validation_overrides(\n        resource_id=resource_id,\n        validation_overrides=overrides,\n        validation_override_service=validation_override_service,\n    )\n</code></pre> <p>Service usage in application layer</p> <p>Dependency wiring is not used in application layer (except async tasks). Any business method or class uses only interfaces.</p> <pre><code>async def patch_validation_overrides(\n    resource_id: str,\n    validation_override: ValidationOverrideInput,\n    validation_override_service: ValidationOverrideService,\n) -&gt; ValidationOverrideList:\n    repo = validation_override_service\n    overrides_content = await repo.get_validation_overrides(resource_id=resource_id)\n    version = overrides_content.validation_version\n</code></pre>"},{"location":"design/aspects/dependency_inversion/#dependency-injection-to-call-async-tasks","title":"Dependency injection to call async tasks","text":"<p>Example</p> <p>Async tasks are defined  in <code>application</code> layer and  can be called from <code>application</code> or <code>presentation</code> layer. They are entrypoints to run remote tasks on remote workers, so async tasks can define parameters to be injected by dependency injection mechanism.</p> <p>The following example shows an example usage of dependency injection in async tasks.</p> <p>///</p> <pre><code>import logging\nfrom typing import Union\n\nfrom dependency_injector.wiring import Provide, inject\n\nfrom mtbls.application.decorators.async_task import async_task\nfrom mtbls.application.remote_tasks.common.run_validation import (\n    run_validation_task,\n    run_validation_task_with_modifiers,\n)\nfrom mtbls.application.remote_tasks.common.utils import run_coroutine\nfrom mtbls.application.services.interfaces.async_task.async_task_result import (\n    AsyncTaskResult,\n)\nfrom mtbls.application.services.interfaces.policy_service import PolicyService\nfrom mtbls.application.services.interfaces.study_metadata_service_factory import (\n    StudyMetadataServiceFactory,\n)\nfrom mtbls.domain.shared.validator.types import ValidationPhase\n\nlogger = logging.getLogger(__name__)\n\n\n@async_task(queue=\"common\")\n@inject\ndef run_validation(  # noqa: PLR0913\n    *,\n    resource_id: str,\n    apply_modifiers: bool = True,\n    phases: Union[ValidationPhase, None, list[str]] = None,\n    serialize_result: bool = True,\n    study_metadata_service_factory: StudyMetadataServiceFactory = Provide[\n        \"services.study_metadata_service_factory\"\n    ],\n    policy_service: PolicyService = Provide[\"services.policy_service\"],\n    **kwargs,\n) -&gt; AsyncTaskResult:\n    try:\n        modifier_result = None\n        if apply_modifiers:\n            coroutine = run_validation_task_with_modifiers(\n                resource_id,\n                study_metadata_service_factory=study_metadata_service_factory,\n                policy_service=policy_service,\n                phases=phases,\n                serialize_result=serialize_result,\n            )\n        else:\n            coroutine = run_validation_task(\n                resource_id,\n                modifier_result=modifier_result,\n                study_metadata_service_factory=study_metadata_service_factory,\n                policy_service=policy_service,\n                phases=phases,\n                serialize_result=serialize_result,\n            )\n        return run_coroutine(coroutine)\n    except Exception as ex:\n        logger.error(\"Validation task execution for %s failed.\", resource_id)\n        logger.exception(ex)\n        raise ex\n    finally:\n        logger.info(\"Validation task execution for %s ended.\", resource_id)\n</code></pre>"},{"location":"design/aspects/dependency_inversion/#unit-tests-and-overrided-dependency-containers","title":"Unit tests and overrided dependency containers","text":"<p>Example</p> <p>You can override containers any time but the most common case is unit tests.</p> <p>The following example shows an example how to override container to use:   - local database   - in-memory cache   - standalone authentication service</p> <p>It also overrides configuration file to fetch configurations of local database, in-memory cache and standalone authentication service.</p> <pre><code>from pathlib import Path\nfrom typing import Any\n\nimport pytest\nimport yaml\n\nfrom mtbls.infrastructure.auth.standalone.standalone_authentication_config import (\n    StandaloneAuthenticationConfiguration,\n)\nfrom mtbls.infrastructure.auth.standalone.standalone_authentication_service import (\n    AuthenticationServiceImpl,\n)\nfrom mtbls.infrastructure.cache.in_memory.in_memory_cache import InMemoryCacheImpl\nfrom mtbls.infrastructure.persistence.db.sqlite.config import SQLiteDatabaseConnection\nfrom mtbls.infrastructure.persistence.db.sqlite.db_client_impl import (\n    SQLiteDatabaseClientImpl,\n)\nfrom mtbls.run.rest_api.submission.containers import Ws3ApplicationContainer\n\n\n@pytest.fixture(scope=\"module\")\ndef submission_api_config() -&gt; dict[str, Any]:\n    with Path(\"tests/data/config/submission_base_config.yaml\").open(\"r\") as f:\n        return yaml.safe_load(f)\n\n\n@pytest.fixture(scope=\"module\")\ndef submission_api_container(submission_api_config) -&gt; Ws3ApplicationContainer:\n    container = Ws3ApplicationContainer()\n    # Override config\n    container.config.override(submission_api_config)\n    # Override Cache\n    container.services.cache_service.override(InMemoryCacheImpl())\n    # Override Database gateway\n    connection_json = container.config.gateways.database.sqlite.connection()\n    db_connection = SQLiteDatabaseConnection.model_validate(connection_json)\n    container.gateways.database_client.override(SQLiteDatabaseClientImpl(db_connection))\n    # Override Authentication service\n    standalone_auth_config_str = container.config.services.authentication.standalone()\n    standalone_auth_config = StandaloneAuthenticationConfiguration.model_validate(\n        standalone_auth_config_str\n    )\n    container.services.authentication_service.override(\n        AuthenticationServiceImpl(\n            config=standalone_auth_config,\n            cache_service=container.services.cache_service(),\n            user_read_repository=container.repositories.user_read_repository(),\n        )\n    )\n\n    return container\n</code></pre>"},{"location":"design/aspects/logging/","title":"Logging","text":"<p>Logging mechanism is based on Python logging module. It is extended to implement the following logging requirements:</p> <ul> <li>Each log will be traceable to identify time, requester, source IP, endpoint and requested resource (MTBLS, REQ)</li> <li>Each log has a request id to find all logs triggered by the same request.</li> <li>Each async task will log with the task id.</li> <li>Logs will not contain personal credentials or PII (Personally Identifiable Information)</li> </ul>"},{"location":"design/aspects/logging/#general-design-and-coding-principles","title":"General design and coding principles","text":"<ul> <li>Each module uses its own logger  (logger with <code>__name__</code> ) to log its state and progress.</li> <li>Use logging module instead of <code>print</code> lines.</li> <li>Prefer logging statement deferred string formatting instead of f-string or string format.</li> </ul> <pre><code>import logging\n\nlogger = logging.getLogger(__name__)\n\nindex = 1\nvalue = \"data\"\n\nlogger.error(\"Error at %s: %s\", index, value)\n\n# instead of\nlogger.error(f\"Error at {index}: {value}\")\n# or\nlogger.error(\"Error at {}: {}\".format(index, value))\n</code></pre> <p>Hint</p> <p>These design principles will be checked with linter automatically.</p>"},{"location":"design/aspects/logging/#logging-configuration","title":"Logging configuration","text":"<p>Each application can have custom logging configuration and logging filter classes.</p> <p>Logging configurations have both <code>json</code> and <code>text</code> formatters. Each formatter can also print some additional information for each log:</p> <ul> <li><code>resource_id</code> to track requested study (MTBLS or REQ id)</li> <li><code>user_id</code> to track authenticated user. It is unique user id in database</li> <li><code>route path</code> to track target endpoint.</li> <li><code>request_id</code> to track all logs triggered by the same request.</li> <li><code>task_id</code> to track all task logs triggered by the same task</li> <li><code>client</code> to track IP address or host of the requester</li> </ul> <p>An example logging configuration is below:</p> <pre><code>logging:\n  version: 1\n  disable_existing_loggers: true\n  formatters:\n    json_formatter:\n      format: '{ \"level_name\": \"%(levelname)s\", \"time\": \"%(asctime)s\",  \"client\": \"%(client)s\",  \"path\": \"%(route_path)s\", \"resource_id\": \"%(resource_id)s\", \"user\": %(user_id)d, \"request_id\": \"%(request_id)s\", \"name\": \"%(name)s\", \"message\": \"%(message)s\" }'\n    text_formatter:\n      format: '%(levelname)-8s %(asctime)s %(user_id)d %(client)s %(route_path)s %(resource_id)s %(request_id)s %(name)s \"%(message)s\"'\n  handlers:\n    console:\n      class: \"logging.StreamHandler\"\n      level: DEBUG\n      formatter: \"text_formatter\"\n      stream: \"ext://sys.stdout\"\n      filters: [ default_filter, correlation_id ]\n  root:\n    level: DEBUG\n    handlers: [ \"console\" ]\n    propogate: true\n  loggers:\n    mtbls:\n      level: DEBUG\n      propogate: yes\n  filters:\n    correlation_id:\n      (): \"asgi_correlation_id.CorrelationIdFilter\"\n      default_value: \"-\"\n    default_filter:\n      (): \"mtbls.run.rest_api.submission.log_filter.DefaultLogFilter\"\n</code></pre> <p>Example JSON log</p> <pre><code>{ \"level_name\": \"DEBUG\", \"time\": \"2024-12-22 18:39:02,218\",  \"client\": \"127.0.0.1\",  \"path\": \"/auth/v1/token\", \"resource_id\": \"-\", \"user\": 0, \"request_id\": \"60335885-b4a0-486b-bc77-2bfa52ebaf2f\", \"name\": \"mtbls.presentation.rest_api.core.authorization_middleware\", \"message\": \"Unauthenticated user requests POST /auth/v1/token from host/IP 127.0.0.1.\" }\n{ \"level_name\": \"INFO\", \"time\": \"2024-12-22 18:39:02,239\",  \"client\": \"127.0.0.1\",  \"path\": \"/auth/v1/token\", \"resource_id\": \"-\", \"user\": 0, \"request_id\": \"60335885-b4a0-486b-bc77-2bfa52ebaf2f\", \"name\": \"mtbls.infrastructure.auth.mtbls_ws2.mtbls_ws2_authentication_proxy\", \"message\": \"Login request from: help@ebi.ac.uk\" }\n{ \"level_name\": \"INFO\", \"time\": \"2024-12-22 18:39:02,370\",  \"client\": \"127.0.0.1\",  \"path\": \"/auth/v1/token\", \"resource_id\": \"-\", \"user\": 0, \"request_id\": \"60335885-b4a0-486b-bc77-2bfa52ebaf2f\", \"name\": \"uvicorn.access\", \"message\": \"127.0.0.1:51279 - \"POST /auth/v1/token HTTP/1.1\" 200\" }\n{ \"level_name\": \"DEBUG\", \"time\": \"2024-12-22 18:39:16,340\",  \"client\": \"127.0.0.1\",  \"path\": \"/submissions/v1/investigation-files/MTBLS60\", \"resource_id\": \"MTBLS60\", \"user\": 25432, \"request_id\": \"54eb7ab4-675c-4ee7-8637-819fdf876105\", \"name\": \"mtbls.presentation.rest_api.core.authorization_middleware\", \"message\": \"User 25432 requests GET /submissions/v1/investigation-files/MTBLS60 from host/IP 127.0.0.1. Target resource id: MTBLS60\" }\n{ \"level_name\": \"DEBUG\", \"time\": \"2024-12-22 18:39:16,340\",  \"client\": \"127.0.0.1\",  \"path\": \"/submissions/v1/investigation-files/MTBLS60\", \"resource_id\": \"MTBLS60\", \"user\": 25432, \"request_id\": \"54eb7ab4-675c-4ee7-8637-819fdf876105\", \"name\": \"mtbls.presentation.rest_api.groups.auth.v1.routers.dependencies\", \"message\": \"User 25432 is granted to update resource MTBLS60\" }\n{ \"level_name\": \"INFO\", \"time\": \"2024-12-22 18:39:16,890\",  \"client\": \"127.0.0.1\",  \"path\": \"/submissions/v1/investigation-files/MTBLS60\", \"resource_id\": \"MTBLS60\", \"user\": 25432, \"request_id\": \"54eb7ab4-675c-4ee7-8637-819fdf876105\", \"name\": \"uvicorn.access\", \"message\": \"127.0.0.1:51283 - \"GET /submissions/v1/investigation-files/MTBLS60 HTTP/1.1\" 200\" }\n</code></pre> <p>A <code>RequestTracker</code> object is created for each request automatically. Custom logging filters defined in logging configuration inject additional information using the <code>RequestTracker</code> object for the request.</p> <pre><code>from logging import Filter, LogRecord\n\nfrom mtbls.application.context.request_tracker import (\n    RequestTracker,\n    get_request_tracker,\n)\n\nclass DefaultLogFilter(Filter):\n    #...\n\n    def filter(\n        self,\n        record: LogRecord,\n    ) -&gt; bool:\n        #...\n        context_vars = get_request_tracker()\n        if context_vars and isinstance(context_vars, RequestTracker):\n            model = context_vars.get_request_tracker_model()\n            record.user_id = model.user_id\n            record.route_path = model.route_path\n            record.resource_id = model.resource_id\n            record.client = model.client\n            record.request_id = model.request_id\n            record.task_id = model.task_id\n        else:\n            record.user_id = 0\n            record.route_path = \"-\"\n            record.resource_id = \"-\"\n            record.client = \"-\"\n            record.request_id = \"-\"\n            record.task_id = \"-\"\n\n        return True\n</code></pre>"},{"location":"design/aspects/logging/#management-of-additional-logging-information","title":"Management of additional logging information","text":"<ul> <li> <p>REST API executables: <code>AuthorizationMiddleware</code> updates additional information.</p> </li> <li> <p>Async Task Workers:</p> <ul> <li>Async task executor adds <code>request_tracker</code> parameter with <code>RequestTracker</code> data.</li> <li>Before starting async task execution on remote worker, <code>request_tracker</code> parameter is checked and updates additional information.</li> </ul> </li> </ul> <pre><code>class CeleryAsyncTaskExecutor(AsyncTaskExecutor):\n    def __init__(\n        self, task_method: Callable, task_name: str, id_generator: IdGenerator, **kwargs\n    ):\n        self.task_method = task_method\n        self.kwargs = kwargs\n        self.task_name = task_name\n        self.id_generator = id_generator\n\n    async def start(self, expires: Union[None, int] = None) -&gt; AsyncTaskResult:\n        request_tracker = get_request_tracker().get_request_tracker_model().model_dump()\n        self.kwargs[\"request_tracker\"] = request_tracker\n        if self.id_generator:\n            task_id = self.id_generator.generate_unique_id()\n            task = self.task_method.apply_async(\n                expires=expires,\n                kwargs=self.kwargs,\n                task_id=task_id,\n            )\n        else:\n            task = self.task_method.apply_async(expires=expires, kwargs=self.kwargs)\n        logger.info(\"Task '%s' is created.\", self.task_name)\n        return CeleryAsyncTaskResult(task)\n</code></pre> <pre><code>class CeleryBaseTask(celery.Task):\n    def on_failure(self, exc, task_id, args, kwargs, einfo):\n        logger.error(\"%s failed: %s\", task_id, str(exc))\n\n    def before_start(self, task_id, args, kwargs):\n        request_tracker = get_request_tracker()\n        request_tracker.task_id_var.set(task_id)\n        if \"request_tracker\" in kwargs:\n            request_tracker_dict = kwargs[\"request_tracker\"]\n</code></pre>"},{"location":"development/general/","title":"General","text":"<ul> <li>Python <code>pathlib.Path</code> package is used instead of <code>os.path</code></li> </ul>"}]}